# Gazebo as a server for the RoboCup 3D simulation league.

## Overview

The RoboCup 3D simulation league currently uses [Simspark](http://simspark.sourceforge.net/wiki/index.php/Main_Page) as a server. In this league,
teams develop a set of agents that interact with the simulation to compete in a
soccer game with another team. The communication between agents and server is
performed via TCP sockets. Messages from and to the server use S-expressions as
message format.

[This link](http://simspark.sourceforge.net/wiki/index.php/Network_Protocol)
contains all the information about the network protocol and the message format.
As a summary, agents can request effector commands for spawning new robots,
modify the joints of a particular robot or even send a communication message to
a teammate. Once a connection with an agent is stablished, the server can also
send perception information to the agent. This information contains ball
position, landmark poses, or parts from other robots seen by the current camera
view of the robot. Note that the agents do not have to process any images at
all, all the perception is generated by the server and delivered as a Perceptor
message to the agent.

In addition to agents communicating with the server, it is also possible to
connect a Monitor (similar to gzclient) to the server for scene visualization.
The server is listening in a different port for this purpose, and will send to
the monitor updates in Ruby Scene Graph format.

## Architecture

All the functionality will be contained in a world plugin named
Robocup3dsPlugin. The functionality inside the plugin will be divided in several
files:

* Server.cc: A class named Server will initialize some sockets and will listen
in TCP ports 3100 and 3200 for agent and monitor communication. We'll try to use
an S-expression library to parse the incoming messages and to send the outgoing
messages.

* GameState.cc: A class named GameState will keep track of the time and will
update the state machine with all the different game situations: beforeKickOff,
kickoff, play, corner, goal, etc.

* Perceptor.cc: We will include in this file all the Perceptor classes.
Following the different type of [perceptors available](http://simspark.sourceforge.net/wiki/index.php/Perceptors), we'll create the following clases:
GyroRatePerceptor, HingeJointPerceptor, UniversalJointPerceptor,
TouchPerceptor, ForceResistancePerceptor, AccelerometerPerceptor,
VisionPerceptor, RestrictedVisionPerceptor, GameStatePerceptor,
RestrictedVisionPerceptor and HearPerceptor. All of them will inherit from a
Perceptor class.

* Effector.cc:

* Robocup3dsPlugin.cc: The plugin will create one instance of a Server and a GameState. It will create a separate thread that will execute the method
server.start() for start receiving external requests. The plugin will also
register the Update() callback. Update() will perform the main simulation update
loop in the following way:

...
{
  Sense()
  Act()
  UpdatePhysics()
  UpdateGameState()
}
...

Sense() will generate the perceptions for all the players connected to the
server. The perceptions will be stored in a data structure shared by the plugin
and the server thread. The plugin will produce new perceptor data, while the
server will consume it.

Following the Sense() approach but in the opposite direction, the server will
update a shared data structure with effector commands to be executed in the next
update. Act() will consume all the efector commands: move joints, spawn new
robots, move the ball, etc.

UpdatePhysics() will move forward the world. The RoboCup 3D simulation rules
say that updates must be executed at 50 Hz. Probably we will have to run faster
than 50 Hz to maintain the simulation stability. In any case, we will always run
Sense(), Act() and UpdateGameState() at the given frequency.


## Models and worlds

## Testing

## Pull requests