## Project: Time series 2d data plots
***SDF Design Document***

### Overview

Gazebo simulations can generate a lot of useful data. It would be useful to be
 able to see some of that data in real time on 2d plots. This can be done in
 C++ and QT inside Gazebo, or as a separate application using GazeboJs.

### Requirements

1. Identify useful numerical data source and make them available
 for plotting.
1. Configure plots (min, max, colors, sampling rate, data buffer size).
1. Save the plot and or the data
1. (Nice to have) Specify derived values (like combining X, Y, Z positions to plot a distance).
1. Compare plots between runs
1. Compute difference in value between two points on a plot

### User Interaction

Here is a high level design of what this tool could look like. It is written
 for an implementation inside Gazebo, but the UI can also apply to an external
 application.

[plotting v3](https://bitbucket.org/osrf/gazebo_design/raw/db9782356501878b0df60b396f9d54860cc7d28c/time_series_2d_plots/Plotting_v3.pdf)


### Plottable Data

In simulation, the physics server generates large volumes of data over time.
Here is a list of physics data that should be made available to the plotting
tool.

**Topics**

Only numerical fields in messages can be plotted

**Model**

  - pose

  - **Link**
    - pose
    - angular acceleration
    - angular velocity
    - linear acceleration
    - linear velocity
    - force
    - torque

    - **Inertial**
        - pose
        - angular acceleration
        - angular velocity
        - linear acceleration
        - linear velocity

    - **Collision**
        - pose

    - **Visual**
        - pose

  - **Joint**
    - pose
    - angle
    - force
    - torque
    - velocity

  - **Model**
    - ...

**Simulation**

  - sim time

  - real time

  - iterations

  - real time factor

The three different categories of data shown above correspond to the those in
the left panel of the plotting tool as shown in the
[plotting v3](https://bitbucket.org/osrf/gazebo_design/raw/db9782356501878b0df60b396f9d54860cc7d28c/time_series_2d_plots/Plotting_v3.pdf)
design document.

### Implementation

**Topics**

The plotting tool will subscribe to Gazebo topics upon user selection from
a Gazebo topics list similar to the Topic Viewers. It needs to be able to
identify the message type for that topic and list the fields that can be
plotted. Protobuf message reflection could be used to help to retrieve the names
and data types for the fields in the message.

Here is an example showing the plottable fields for the message type
`gazebo.msgs.PosesStamped` published to the `~/pose/local/info` topic:

~~~
gazebo.msgs.PosesStamped
  + time
  + pose
~~~

Expanding the `time` field will reveal more fields:

~~~
gazebo.msgs.PosesStamped
  - time
      - sec
      - nsec
  + pose
~~~

Since `pose` is a repeated field in the `gazebo.msgs.PosesStamped` message,
expanding the pose field will show an array of elements in `pose`.

~~~
gazebo.msgs.PosesStamped
  + time
  - pose
      - [0] [1] [2] [3] [4] [5]
      - name
      - id
      - position
        - x
        - y
        - z
      - orientation
        - x
        - y
        - z
        - w
~~~

Clicking on an index number within the [x] bracket will highlight it and expose
the fields of the `gazebo.msgs.Pose` message. The string value of the `name`
field could be displayed next to the label but it will not be plottable. The
numerical fields can be dragged over to the plotting area to begin plotting.

**Model**

Not all data generated by the physics server, such as link velocity and
acceleration, are currently available to the GUI client. Neither are these data
published to topics nor accessible using the Gazebo request-response channel.

We are going to create an Ignition Transport service that will provide the
ability to receive custom world updates on a new topic. The plotting tool will
be the first client of this service but this feature might be useful for other
components.

The client will need to prepare a request message containing the specific
elements of interest and the entity that they belong. E.g.: The plotting tool
sets a filter for the element "position" of the entity "unit_box_0" and the
element "linear_vel" of the entity "unit_cylinder_0".

The World class will provide the previously mentioned service and will keep a
list of custom updates requested by clients. For each new update received, a
new topic will be created and announced. Also, at the end of each world update,
we'll iterate through the list of custom requests and populate a message
calling the appropriate physics primitives (e.g.: get the world pose of the
model "unit_box_0" and the linear velocity of "unit_cylinder_0"). A single
message will be sent for each custom update requested in each simulation update.
 Each request will be received through ts own topic.

We can use [this message definition](https://bitbucket.org/osrf/gazebo_design/src/f864f029fdd15347e6bbb4e2e46c6ce84e56a9ec/physics_params/physics_params.md?at=default&fileviewer=file-view-default) for specifying the filters used in
the services requests, as well as for the messages containing the custom
updates.

**Simulation**

Simulation data are available via the  `~/world_stats` topic.

**External sources of data**

It would be convenient for our power users to allow them to plot variables that
are not contained in the core of Gazebo. E.g.: variables in plugins or
standalone programs. For these scenarios, we'll use a newly design class that
provides introspection capabilities via transport. Here's an example of how to
declare a variable with introspection capabilities:

~~~
IntrospectVar<double> d1("/introspection/d1");
~~~

Each time a new value is assigned to this variable, a new update is published
over the topic "/introspection/d1" using Ignition Transport.

We'll let the users to use this functionality at their own discretion. Back to
the plotting tool, we could show all the introspection variables under a
different tab. In the took, we'll process these external topics in the same way
we'll process the internal topics.

### Notes about GazeboJs

There are multiple graph libraries for JavaScript (d3, flot, sigmajs ...) that
 can be used to make a graph utility for Gazebo. The graphing feature can than
 be added to GZweb, and also packaged as a stand alone application with a
 toolkit like [electron](https://github.com/atom/electron).

GazeboJs cannot access new types of messages that are created by Plugins.
