## Project: Time series 2d data plots
***SDF Design Document***

### Overview

Gazebo simulations can generate a lot of useful data. It would be useful to be
 able to see some of that data in real time on 2d plots. This can be done in
 C++ and QT inside Gazebo, or as a separate application using GazeboJs.

### Requirements

1. Identify useful numerical data source and make them available
 for plotting.
1. Configure plots (min, max, colors, sampling rate, data buffer size).
1. Save the plot and or the data
1. (Nice to have) Specify derived values (like combining X, Y, Z positions to plot a distance).
1. Compare plots between runs
1. Compute difference in value between two points on a plot

### User Interaction

Here is a high level design of what this tool could look like. It is written
 for an implementation inside Gazebo, but the UI can also apply to an external
 application.

[plotting v3](https://bitbucket.org/osrf/gazebo_design/raw/db9782356501878b0df60b396f9d54860cc7d28c/time_series_2d_plots/Plotting_v3.pdf)


### Plottable Data

In simulation, the physics server generates large volumes of data over time.
Here is a list of physics data that should be made available to the plotting
tool.

**Topics**

Only numerical fields in messages can be plotted

**Model**

  - pose

  - **Link**
    - pose
    - angular acceleration
    - angular velocity
    - linear acceleration
    - linear velocity
    - force
    - torque

    - **Inertial**
        - pose
        - angular acceleration
        - angular velocity
        - linear acceleration
        - linear velocity

    - **Collision**
        - pose

    - **Visual**
        - pose

  - **Joint**
    - pose
    - angle
    - force
    - torque
    - velocity

  - **Model**
    - ...

**Simulation**

  - sim time

  - real time

  - iterations

  - real time factor

The three different categories of data shown above correspond to the those in
the left panel of the plotting tool as shown in the
[plotting v3](https://bitbucket.org/osrf/gazebo_design/raw/db9782356501878b0df60b396f9d54860cc7d28c/time_series_2d_plots/Plotting_v3.pdf)
design document.

### Implementation

**Topics**

The plotting tool will subscribe to Gazebo topics upon user selection from
a Gazebo topics list similar to the Topic Viewers. It needs to be able to
identify the message type for that topic and list the fields that can be
plotted. Protobuf message reflection could be used to help to retrieve the names
and data types for the fields in the message.

Here is an example showing the plottable fields for the message type
`gazebo.msgs.PosesStamped` published to the `~/pose/local/info` topic:

~~~
gazebo.msgs.PosesStamped
  + time
  + pose
~~~

Expanding the `time` field will reveal more fields:

~~~
gazebo.msgs.PosesStamped
  - time
      - sec
      - nsec
  + pose
~~~

Since `pose` is a repeated field in the `gazebo.msgs.PosesStamped` message,
expanding the pose field will show an array of elements in `pose`.

~~~
gazebo.msgs.PosesStamped
  + time
  - pose
      - [0] [1] [2] [3] [4] [5]
      - name
      - id
      - position
        - x
        - y
        - z
      - orientation
        - x
        - y
        - z
        - w
~~~

Clicking on an index number within the [x] bracket will highlight it and expose
the fields of the `gazebo.msgs.Pose` message. The string value of the `name`
field could be displayed next to the label but it will not be plottable. The
numerical fields can be dragged over to the plotting area to begin plotting.

**Model**

Not all data generated by the physics server, such as link velocity and
acceleration, are currently available to the GUI client. Neither are these data
published to topics nor accessible using the Gazebo request-response channel.

We are going to create a new Gazebo service that provides the ability to
instrospect data. There are two groups of introspection clients. The first group
is composed by the data providers (e.g.: physics, plugins). The second group can
query the introspection service for knowing the list of available items, as
well as registering interest in one or more of the items announced. Then, they
will receive periodic updates with the requested items. The plotting tool falls
under the second group, it is considered a data consumer.

We'll write a new singleton-based IntrospectionManager class that will expose
the following C++ interface to be used by the data providers:

~~~
bool Register(const std::string &_item, const std::function <bool (gazebo::msgs::GzAny &_msg)> &_cb);
bool Unregister(const std::string &_item);
~~~

As an example, Physics will use introspection in the following way:

~~~
// Introspection callback.
bool gazebo::physics::Entity::IntrospectionUpdatePose(gazebo::msgs::GzAny &_msg)
{
  // Copy into the message the variable[s] that you want to introspect.
  auto pose = this->GetWorldPose();
  _msg.set_xxx(pose);

  return true;
}
~~~

Now, in the World class, each time a new model is inserted in the world, we
register a new item:
~~~
  // Model creation.
  gazebo::physics::ModelPtr newModel = ...;

  auto introspection = gazebo::utils::Introspection::Instance();

  introspection.Register(newModel->GetName() + "::pose",
      std::bind(&Entity::IntrospectionUpdatePose, newModel));
~~~

Notice that World needs to instantiate an IntrospectionManager object and
register the item with a callback. `GzAny` will be a
protobuf Message similar to the `Param` message definition designed [here](https://bitbucket.org/osrf/gazebo_design/src/f864f029fdd15347e6bbb4e2e46c6ce84e56a9ec/physics_params/physics_params.md?at=default&fileviewer=file-view-default). The most common Gazebo types will
be supported.

The introspection manager will also provide the following Ignition Transport
services targeted to the data consumers:

~~~
/introspection/<manager_id>/items
~~~

  Service that will return the list of available items and their types.

~~~
/introspection/<manager_id>/set_filter
~~~

    Service that will be used by a client to set a new filter containing a list of
    items of interest. This service will create a new topic and the items will be
    periodically sent through that channel. We can also use this service for
    updating an existing filter.

~~~
/introspection/<manager_id>/remove_fiter
~~~

    Service that will allow a client to remove a filter when not needed anymore.

~~~
/introspection/<manager_id>/get_filter
~~~

    Service that will allow a client to get the list of items contained in a
    previously created filter.

The plotting tool will query the introspection manager for knowing the list of
items available and displaying the list to our users.

The tool will also create a new filter containing the specific items of
interest. E.g.: A filter for the items "unit_box_0::position" and
"unit_cylinder_0::linear_vel".

At the end of each world update, the InstrospectionManager will iterate through
the list of custom requests and populate messages calling the appropriate
registered callbacks (e.g.: get the world pose of the model "unit_box_0" and the
linear velocity of "unit_cylinder_0"). A single message will be sent for each
custom update requested in each simulation update. Each request will be received
through ts own topic.

**Simulation**

Simulation data are available via the  `~/world_stats` topic.

**External sources of data**

It would be convenient for our power users to allow them to plot variables that
are not contained in the core of Gazebo. E.g.: variables in plugins or
standalone programs. For these scenarios, we'll use the introspection service as
previously described.

In the case of a standalone program that uses instrospection, we'll end up with
two Instrospection managers running at the same type in different processes.
The services advertised by each Instrospection manager will contain a unique
`<manager_id>`. The tools consuming introspection data should take the
possibility of having multiple managers into account for querying the list of
available items or requesting filters.

### Notes about GazeboJs

There are multiple graph libraries for JavaScript (d3, flot, sigmajs ...) that
 can be used to make a graph utility for Gazebo. The graphing feature can than
 be added to GZweb, and also packaged as a stand alone application with a
 toolkit like [electron](https://github.com/atom/electron).

GazeboJs cannot access new types of messages that are created by Plugins.
